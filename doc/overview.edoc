@author Ruslan Babayev <ruslan@babayev.com>
@copyright 2009 Ruslan Babayev
@version 1.0.0
@title http - Erlang HTTP/1.1 client and server. 
@doc This is an implementation of an HTTP/1.1 compliant client and server,
as defined in RFC 2616.

== Introduction ==
To start the server with default configuration:
<pre>
erl -s http
</pre>

You can override defaults by providing your own configuration file:
<pre>
erl -s http -config test
</pre>
where test.config contains something like:
<pre>
[{http, [{port, 8080},
         {idle_timeout, 10000},
         {docroot, "/Users/ruslan/mydocroot"},
         {modules, [http_mod_scheme,
                    http_mod_options,
                    http_mod_alias]},
         {services, []}
        ]}].
</pre>
or you can override individual environment variables on command line:
<pre>
erl -s http -http docroot '"/Users/ruslan/mydocroot"' port 8081
</pre>

Variables specified on the command line override those in .config file.

== Modules API ==
The process of handling HTTP requests involves several steps, such as:
<ul>
  <li>Setting up connections, sending and receiving data from the socket.</li>
  <li>URI to file name translation.</li>
  <li>Authentication and access control.</li>
  <li>Retrieving and generating HTTP response.</li>
  <li>Logging</li>
</ul>

To provide customization and extensibility, request handling can be done by
one or more modules that may be replaced or removed at runtime. For each HTTP
request all modules will be traversed in the order specified by the `modules'
environment variable of the `http' application.

A module can modify the HTTP request, response and flags generated by previous
modules before passing them to the consecutive modules.

Each module must implement the following callback functions:
<ul>
  <li>init/0</li>
  <li>handle/4</li>
</ul>

The handler must return one of the following:
<dl>
  <dt>`{proceed, Request, Response, Flags}'</dt>
  <dd>Pass the `Request', `Response' and the `Flags' to the next module
      in the `modules' list. If this was the last module, send `Response'
      to the client.</dd>
  <dt>`#http_response{}'</dt>
  <dd>Modules traversal is complete. Send the response to the client.</dd>
  <dt>`already_sent'</dt>
  <dd>Modules traversal is complete. The response has already been sent.</dd>
  <dt>`{error, closed}'</dt>
  <dd>Client socket was closed. Exit the handler.</dd>
  <dt>`{error, Reason}'</dt>
  <dd>The error Reason will be logged and Internal Server Error (500) sent to
      the client.</dd>
</dl>

A simple module that doesn't have any initialization and just forwards the
HTTP response to the next module can look like this:

<pre>
-module(http_mod_test).
-export([init/0, handle/4]).

init() ->
    ok.

handle(_Socket, Request, Response, Flags) ->
    {proceed, Request, Response, Flags}.
</pre>
